# Email Scheduling System 

## Overview

This repository contains a **production‑grade Email Scheduling System** implemented as a complete end‑to‑end project.

The project includes **both Producer and Consumer services**, persistent storage, and asynchronous processing to reliably send scheduled emails at scale.

The system is designed to:

* Accept email campaign requests via REST API
* Persist campaign and scheduling data
* Process email delivery asynchronously
* Support delayed execution and rate limits
* Run safely in real production environments

This repository represents the **entire system**, not a single component.

---

## System Components

### 1. Email Producer Service

Responsible for receiving email campaign requests and preparing delivery jobs.

**Responsibilities**

* Exposes REST APIs for campaign creation
* Validates scheduling, limits, and recipients
* Stores campaign metadata in MySQL
* Breaks campaigns into individual email tasks
* Publishes tasks for asynchronous processing

The producer **never sends emails directly**.

---

### 2. Message Queue (Kafka)

Provides reliable, durable task hand‑off between producer and consumer services.

**Role in this project**

* Stores email delivery tasks generated by the producer
* Allows consumer service to start late or restart safely
* Decouples request handling from email sending
* Enables horizontal scaling of consumers

Kafka is used strictly for **delivery tasks**, not business data.

---

### 3. Email Consumer Service

Consumes queued email tasks and performs actual delivery.

**Responsibilities**

* Reads email tasks from the queue
* Applies delay and scheduling rules
* Enforces hourly rate limits
* Sends emails using SMTP / provider
* Updates delivery status

The consumer can be started **before or after** the producer.

---

### 4. Database (MySQL)

Stores system‑critical data.

**What is stored**

* Campaign metadata
* Scheduling configuration
* Rate limits
* Campaign status

**What is not stored**

* Queue offsets
* Transient delivery events

---

## End‑to‑End Flow

1. Client creates an email campaign via REST API
2. Producer validates the request
3. Campaign metadata is stored in MySQL
4. Producer generates one delivery task per recipient
5. Tasks are queued reliably
6. Consumer reads tasks when available
7. Emails are sent respecting delay and rate limits
8. Delivery status is updated

At no point is data lost if any component restarts.

---

## API Contract

### Create Email Campaign

**POST** `/api/v1/email/campaign`

**Request Body**

```json
{
  "userId": 1,
  "subject": "Test Campaign",
  "body": "Hello, this is a test email.",
  "startTime": "2026-01-25T12:00:00Z",
  "delaySeconds": 60,
  "hourlyLimit": 10,
  "recipients": [
    "user1@example.com",
    "user2@example.com"
  ]
}
```

**What happens internally**

* Campaign is persisted
* Tasks are generated per recipient
* Tasks are queued for delivery

---

## Data Model (High Level)

### Campaign

* campaign_id
* user_id
* subject
* body
* start_time
* hourly_limit
* status

### Delivery Task

* campaign_id
* recipient
* scheduled_time
* delivery_status

---

## Tech Stack

* Java 17
* Spring Boot
* Apache Kafka
* MySQL 8
* Docker & Docker Compose

---

## Running the System

### Build

```bash
mvn clean package
```

### Start Infrastructure + Services

```bash
docker compose up --build
```

### Services

* Producer API: `http://localhost:8080`
* Consumer: background worker

---

## Design Guarantees

* Fault tolerant
* Consumer‑independent
* Horizontally scalable
* Safe for delayed execution
* Production‑grade separation of concerns

---

## Project Status

✔ End‑to‑end system complete
✔ Producer service implemented
✔ Consumer service implemented
✔ Persistent storage integrated
✔ Dockerized for deployment

---
